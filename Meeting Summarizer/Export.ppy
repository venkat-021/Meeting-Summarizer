# app/services/free_export.py
import json
import csv
from datetime import datetime
from typing import Dict, Any, List
import os

class FreeExportService:
    def __init__(self):
        self.export_formats = ['json', 'csv', 'txt', 'html']
    
    async def export_analysis(self, analysis_data: Dict[str, Any], format: str = 'json') -> str:
        """Export analysis in various formats for free"""
        if format == 'json':
            return await self._export_json(analysis_data)
        elif format == 'csv':
            return await self._export_csv(analysis_data)
        elif format == 'txt':
            return await self._export_text(analysis_data)
        elif format == 'html':
            return await self._export_html(analysis_data)
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    async def _export_json(self, data: Dict[str, Any]) -> str:
        """Export as JSON"""
        # Clean data for JSON serialization
        clean_data = self._clean_for_export(data)
        return json.dumps(clean_data, indent=2, ensure_ascii=False)
    
    async def _export_csv(self, data: Dict[str, Any]) -> str:
        """Export key data as CSV"""
        import io
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow(['Metric', 'Value'])
        
        # Basic metrics
        metrics = [
            ['Meeting Duration', data.get('processing_metadata', {}).get('audio_duration', 0)],
            ['Speaker Count', data.get('speaker_analysis', {}).get('speaker_count', 1)],
            ['Word Count', len(data.get('transcript', {}).get('text', '').split())],
            ['Primary Emotion', data.get('emotion_analysis', {}).get('primary_emotion', 'unknown')],
            ['AI Voice Confidence', data.get('voice_authenticity', {}).get('ai_confidence', 0)],
            ['Content Type', data.get('content_classification', {}).get('content_type', 'unknown')]
        ]
        
        for metric in metrics:
            writer.writerow(metric)
        
        return output.getvalue()
    
    async def _export_text(self, data: Dict[str, Any]) -> str:
        """Export as formatted text report"""
        report = []
        report.append("MEETING INTELLIGENCE REPORT")
        report.append("=" * 50)
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        report.append("")
        
        # Summary section
        report.append("EXECUTIVE SUMMARY")
        report.append("-" * 30)
        summary = data.get('llm_summary', {}).get('summary', 'No summary available')
        report.append(summary)
        report.append("")
        
        # Key metrics
        report.append("KEY METRICS")
        report.append("-" * 30)
        duration = data.get('processing_metadata', {}).get('audio_duration', 0)
        report.append(f"Duration: {duration:.1f} seconds")
        report.append(f"Speakers: {data.get('speaker_analysis', {}).get('speaker_count', 1)}")
        report.append(f"Primary Emotion: {data.get('emotion_analysis', {}).get('primary_emotion', 'unknown')}")
        report.append("")
        
        # Action items
        report.append("ACTION ITEMS")
        report.append("-" * 30)
        action_items = data.get('llm_summary', {}).get('action_items', [])
        for i, item in enumerate(action_items[:5], 1):
            report.append(f"{i}. {item}")
        
        return "\n".join(report)
    
    async def _export_html(self, data: Dict[str, Any]) -> str:
        """Export as HTML report"""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Meeting Intelligence Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .header { background: #f0f0f0; padding: 20px; border-radius: 5px; }
                .section { margin: 20px 0; padding: 15px; border-left: 4px solid #007cba; }
                .metric { display: inline-block; margin: 10px; padding: 10px; background: #e7f3ff; border-radius: 3px; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Meeting Intelligence Report</h1>
                <p>Generated: {generation_time}</p>
            </div>
            
            <div class="section">
                <h2>Executive Summary</h2>
                <p>{summary}</p>
            </div>
            
            <div class="section">
                <h2>Key Metrics</h2>
                {metrics_html}
            </div>
            
            <div class="section">
                <h2>Action Items</h2>
                <ul>{action_items_html}</ul>
            </div>
        </body>
        </html>
        """
        
        # Prepare data
        metrics = [
            f'<div class="metric">Duration: {data.get("processing_metadata", {}).get("audio_duration", 0):.1f}s</div>',
            f'<div class="metric">Speakers: {data.get("speaker_analysis", {}).get("speaker_count", 1)}</div>',
            f'<div class="metric">Emotion: {data.get("emotion_analysis", {}).get("primary_emotion", "unknown")}</div>'
        ]
        
        action_items = data.get('llm_summary', {}).get('action_items', [])
        action_items_html = "".join([f"<li>{item}</li>" for item in action_items[:5]])
        
        return html_template.format(
            generation_time=datetime.now().strftime('%Y-%m-%d %H:%M'),
            summary=data.get('llm_summary', {}).get('summary', 'No summary available'),
            metrics_html="".join(metrics),
            action_items_html=action_items_html
        )
    
    def _clean_for_export(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Clean data for JSON export"""
        def clean_value(value):
            if isinstance(value, (str, int, float, bool, type(None))):
                return value
            elif isinstance(value, (list, tuple)):
                return [clean_value(item) for item in value]
            elif isinstance(value, dict):
                return {str(k): clean_value(v) for k, v in value.items()}
            else:
                return str(value)
        
        return clean_value(data)